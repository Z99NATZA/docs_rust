// 2025-10-21 (ymd)

/*
--------------------------------------------------
| match (1)
--------------------------------------------------
| - ‡πÄ‡∏õ‡πá‡∏ô "expression" ‡πÄ‡∏ä‡πà‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö if
| - ‡πÉ‡∏ä‡πâ‡∏à‡∏±‡∏ö pattern ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡πà‡∏≤ (pattern matching)
| - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö enum, tuple, struct ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÉ‡∏î ‡πÜ ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏¢‡∏Å‡∏Å‡∏£‡∏ì‡∏µ
| - ‡∏ó‡∏∏‡∏Å‡πÄ‡∏Ñ‡∏™‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏∏‡∏Å‡∏Å‡∏£‡∏ì‡∏µ ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ _ ‡πÄ‡∏õ‡πá‡∏ô default
| - ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏Ñ‡∏™‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
--------------------------------------------------
*/

let x = 2;

match x {
    1 => println!("‡∏´‡∏ô‡∏∂‡πà‡∏á"),
    2 => println!("‡∏™‡∏≠‡∏á"),
    _ => println!("‡∏≠‡∏∑‡πà‡∏ô ‡πÜ"), // _ = default
}




/*
--------------------------------------------------
| match (2) - ‡∏Å‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏≤‡∏¢‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
--------------------------------------------------
| - ‡πÉ‡∏ä‡πâ range (‡πÄ‡∏ä‡πà‡∏ô 1..=5) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
| - ‡πÉ‡∏ä‡πâ | ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏ß‡∏°‡∏´‡∏•‡∏≤‡∏¢ pattern ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏™‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
--------------------------------------------------
*/

let n = 4;

match n {
    1 | 2 => println!("‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏≠‡∏á"),
    3..=5 => println!("‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 3 ‡∏ñ‡∏∂‡∏á 5"),
    _ => println!("‡∏ô‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á"),
}




/*
--------------------------------------------------
| match (3) - ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö enum
--------------------------------------------------
| - ‡πÉ‡∏ä‡πâ‡∏à‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å enum variant ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
| - ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏†‡∏≤‡∏¢‡πÉ‡∏ô variant ‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢
--------------------------------------------------
*/

enum Direction {
    Up,
    Down,
    Left,
    Right,
}

let dir = Direction::Left;

match dir {
    Direction::Up => println!("‡∏Ç‡∏∂‡πâ‡∏ô"),
    Direction::Down => println!("‡∏•‡∏á"),
    Direction::Left => println!("‡∏ã‡πâ‡∏≤‡∏¢"),
    Direction::Right => println!("‡∏Ç‡∏ß‡∏≤"),
}




/*
--------------------------------------------------
| match (4) - ‡∏Å‡∏±‡∏ö Option / Result
--------------------------------------------------
| - ‡πÉ‡∏ä‡πâ‡πÅ‡∏ó‡∏ô if let ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ handle ‡∏´‡∏•‡∏≤‡∏¢‡∏Å‡∏£‡∏ì‡∏µ
| - ‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö enum ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Rust
--------------------------------------------------
*/

let maybe = Some(10);

match maybe {
    Some(v) => println!("‡πÄ‡∏à‡∏≠‡∏Ñ‡πà‡∏≤ {}", v),
    None => println!("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤"),
}

let res: Result<i32, &str> = Err("‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß");

match res {
    Ok(val) => println!("‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {}", val),
    Err(e) => println!("‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {}", e),
}




/*
--------------------------------------------------
| match (5) - Destructuring / Binding
--------------------------------------------------
| - ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å tuple, struct, ‡∏´‡∏£‡∏∑‡∏≠ enum ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
| - ‡πÉ‡∏ä‡πâ @ ‡πÄ‡∏û‡∏∑‡πà‡∏≠ bind ‡∏Ñ‡πà‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
| - ‡πÉ‡∏ä‡πâ if guard ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
--------------------------------------------------
*/

let point = (0, 5);

match point {
    (0, y) => println!("‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡πÅ‡∏Å‡∏ô Y, y = {}", y),
    (x, 0) => println!("‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡πÅ‡∏Å‡∏ô X, x = {}", x),
    (x, y) if x == y => println!("‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡πÅ‡∏¢‡∏á ({},{})", x, y),
    n @ (.., _) => println!("‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏≠‡∏∑‡πà‡∏ô {:?}", n),
}




/*
--------------------------------------------------
| match (6) - ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô expression ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤
--------------------------------------------------
| - match ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
| - ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏Ñ‡∏™
--------------------------------------------------
*/

let num = 1;

let text = match num {
    1 => "‡∏´‡∏ô‡∏∂‡πà‡∏á",
    2 => "‡∏™‡∏≠‡∏á",
    _ => "‡∏≠‡∏∑‡πà‡∏ô ‡πÜ",
};

println!("text = {}", text);




/*
--------------------------------------------------
| match (7) - ‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô (nested match)
--------------------------------------------------
| - ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ match ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô match ‡πÑ‡∏î‡πâ
| - ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö enum ‡∏ã‡πâ‡∏≠‡∏ô enum ‡∏´‡∏£‡∏∑‡∏≠ Option<Result<...>>
--------------------------------------------------
*/

let val = Some(Ok(3));

match val {
    Some(Ok(v)) => println!("‡∏Ñ‡πà‡∏≤‡πÇ‡∏≠‡πÄ‡∏Ñ: {}", v),
    Some(Err(e)) => println!("‡∏°‡∏µ error: {}", e),
    None => println!("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤"),
}




/*
--------------------------------------------------
| match (‡∏™‡∏£‡∏∏‡∏õ)
--------------------------------------------------
| ‚úÖ ‡πÉ‡∏ä‡πâ‡∏à‡∏±‡∏ö pattern ‡∏Ç‡∏≠‡∏á‡∏Ñ‡πà‡∏≤ (‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÅ‡∏Ñ‡πà boolean)
| ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô statement ‡πÅ‡∏•‡∏∞ expression
| ‚úÖ ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö enum, tuple, struct, Option, Result
| ‚úÖ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö guard ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (if x > 5)
| ‚úÖ ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏Å‡∏£‡∏ì‡∏µ‡∏î‡πâ‡∏ß‡∏¢ compiler check
|
| ‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏∏‡∏Å pattern (‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô compile error)
| ‚ùå ‡∏ó‡∏∏‡∏Å‡πÄ‡∏Ñ‡∏™‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡πÅ‡∏ö‡∏ö expression
|
| üîπ ‡πÉ‡∏ä‡πâ destructure ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å enum / struct ‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
| üîπ ‡πÉ‡∏ä‡πâ return ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏Å‡∏£‡∏ì‡∏µ‡πÉ‡∏ô‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÑ‡∏î‡πâ
--------------------------------------------------
*/
