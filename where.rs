/*
--------------------------------------------------
| where (1)
--------------------------------------------------
| - คำสั่ง where ใช้จำกัดเงื่อนไขของ (Generic Type, Trait Bound)
|   ให้อ่านง่ายและเป็นระเบียบมากขึ้น ช่วยกำหนดชนิดข้อมูล
|   ที่ส่งเข้ามาต้อง implement trait อะไรบ้าง
| - ตัวอย่างเบื้องต้น
--------------------------------------------------
*/

fn print_size<T: Debug + Clone>(item: T) {
    println!("{:?}", item);
}
// สังเกตว่า T ต้อง implement (Debug, Clone)
// แบบนี้ยาวไป ถ้ามีหลายตัว จะอ่านยาก






/*
--------------------------------------------------
| where (2)
--------------------------------------------------
| - ไม่ใช้ where
| - ตัวอย่าง "มีหลายตัว" (อ่านยาก)
--------------------------------------------------
*/

pub fn post<
    P: AsRef<str>, 
    H: Fn(Request) -> Fut + Send + Sync + 'static, 
    Fut: Future + Send + 'static
>(
    path: P,
    handler: H,
) -> RouteSet
where
    Fut::Output: IntoResponse,
{
    // Code
}






/*
--------------------------------------------------
| where (3)
--------------------------------------------------
| - ใช้ where
| - ✅ แบบนี้ดูดีกว่า
--------------------------------------------------
*/
pub fn post<P, H, Fut>(path: P, handler: H) -> RouteSet
where
    P: AsRef<str>,
    H: Fn(Request) -> Fut + Send + Sync + 'static,
    Fut: Future + Send + 'static,
    Fut::Output: IntoResponse,
{
    // Code
}





/*
--------------------------------------------------
| where (4) แถม (Generic Type)
--------------------------------------------------
| - Generic Type คือชนิดข้อมูลที่กำหนดภายหลัง
| - คือ (struct, enum, impl) ที่ทำงานกับหลายชนิดข้อมูลได้
|   โดยไม่ต้องเขียนซ้ำหลายรอบ
| - ตัวอย่างง่าย ๆ
--------------------------------------------------
*/

fn print_item<T>(item: T) {
    println!("Got something!");
}
// T คือ Generic Type Parameter
// แทนที่จะบังคับว่า item ต้องเป็น i32, String, หรืออื่น ๆ
// เราบอกแค่ "อะไรก็ได้" (compiler ตรวจสอบภายหลังตอนเรียกใช้จริง)

print_item(42);         // T = i32
print_item("hello");    // T = &str
print_item(String::from("Rust")); // T = String





/*
--------------------------------------------------
| where (5) แถม (Trait Bound)
--------------------------------------------------
| - Rust จะไม่ยอมให้ใช้ "อะไรก็ได้" ถ้าไม่รู้ว่าทำอะไรได้บ้าง
| - เราต้อง "จำกัดขอบเขต" ของ Generic Type 
|   ให้ทำงานได้เฉพาะชนิดที่ มีคุณสมบัติบางอย่าง (trait) เท่านั้น
--------------------------------------------------
*/

fn print_debug<T: std::fmt::Debug>(item: T) {
    println!("{:?}", item);
}
// T ต้องเป็นชนิดที่ implement Debug
// ถึงจะใช้ {:?} ใน println! ได้



/*
--------------------------------------------------
| where (6) แถม (Trait Bound) "หลายตัว"
--------------------------------------------------
| - สามารถกำหนดหลาย ๆ constraint ได้โดยใช้ +
--------------------------------------------------
*/

fn clone_and_print<T: Clone + Debug>(item: T) {
    let copy = item.clone();
    println!("{:?}", copy);
}